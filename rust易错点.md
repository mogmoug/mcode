# **Rust易错点**
前言

这个就是记录一些Rust方面的东西

## **语法**
### **if语句后面的括号**
在rust中，if语句一般是不用添加括号的，如果你不小心添加了括号，虽然能通过，但rust编译器还是会给你一个警告
![](img/rust%E6%98%93%E9%94%99%E7%82%B91.bmp)

## **特性**
### **rust中溢出的处理**
在rust中，有专门处理溢出的函数，checked\_add和wrapping\_add

这两个函数，一个是检测溢出的，一个是忽视溢出的

检测溢出函数checked\_add：

这个函数可以在相加之前检测相加的结果会不会溢出，用法checked\_add(加数,加数)

如果不会溢出就可以使用Some(x)取出结果了

如果溢出了，就会得到None

当然其他的运算也是有这样的函数的，比如checked\_sub

忽视溢出强制相加的函数wrapping\_add：

这个函数可以忽视溢出强制相加，用法wrapping\_add(加数,加数)

会输出强行相加后的结果，而溢出了也不会有提示

其他运算的类似函数，例如wrapping\_div

用例

![](img/rust%E6%98%93%E9%94%99%E7%82%B92.bmp)

### **大批量的赋值**
在C语言中我经常会使用for循环来完成大批量的赋值或者数组的复制

但是我在rust中打算这么做时，rust编译器提示我这样做不好

我就了解到了一个函数copy\_from\_slice

这个函数是数组中所包含的一个函数，你可以通过array[..length].copy\_form\_slice(..&hello[..])来使用

![](img/rust%E6%98%93%E9%94%99%E7%82%B93.bmp)

这是我的一个用例，我把program的全部复制到mem数组的开头

官方对此函数的介绍

![](img/rust%E6%98%93%E9%94%99%E7%82%B94.bmp)

大概意思是：

使用memcpy将src的所有元素复制到self

self的长度必须与src的长度相等

如果这个函数没有起作用，请使用clone\_from\_slice函数

**恐慌（panic）的情况：**

如果两个切片（src，self）的长度不相对，函数就会恐慌（panic）

**相关知识：**

Slice

